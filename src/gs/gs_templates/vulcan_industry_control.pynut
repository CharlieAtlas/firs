class VulcanIndustryControl {
    /* structure for industry control */

    // note that this has no constructor as not designed to return a class instance, just a class to hold methods
    function Init() {
        VulcanIndustryControl.SetAllIndustryFlagsToSpec();
    }

    function GetDefaultControlFlags() {
        // can't use class property for these as there's no class instance constructed, so use cheeky function instead
        return GSIndustry.INDCTL_NO_CLOSURE | GSIndustry.INDCTL_NO_PRODUCTION_INCREASE | GSIndustry.INDCTL_NO_PRODUCTION_DECREASE | GSIndustry.INDCTL_EXTERNAL_PROD_LEVEL;
    }

    function SetAllIndustryFlagsToSpec() {
        Log.Info("SetAllIndustryFlagsToSpec called");
        local industry_list = GSIndustryList();
        // asyncmode for speed here as we execute commands over a potentially large number of industries
        local asyncmode = GSAsyncMode(true);
        foreach (industry, _ in industry_list) {
            // set all flags as of June 2023, unset them later per-industry for specific behaviour
            GSIndustry.SetControlFlags(industry, VulcanIndustryControl.GetDefaultControlFlags());
        }
        Log.Info("SetAllIndustryFlagsToSpec done");
    }

    function RollDiceForTownPrimaryIndustryProductionIncrease(vulcan_town) {
        // house keeping
        foreach (industry, industry_spec in vulcan_town.town_industries) {
            if (industry_spec.default_vulcan_config["allow_production_change_from_gs"] == true) {
                // reset any flags to defaults, we have to assume that the grf has meanwhile used the flag to change production
                GSIndustry.SetControlFlags(industry, VulcanIndustryControl.GetDefaultControlFlags());
            }
        }

        local town_can_increase_primary_production = vulcan_town.GetHappiness();
        // limit how often we try to update
        if (vulcan_town.town in ::persistent_storage.town_primary_industry_production_increase_timeseries) {
            local last_increase_date = ::persistent_storage.town_primary_industry_production_increase_timeseries[vulcan_town.town][0];
            // odd but cheap way to add some random jitter
            // this is expressed in days, min 180 (6 months), max 540 (18 months)
            // note this will be a new random amount *every* month, this doesn't extend the delay until the _next_ check
            // the advantage of this over monthly random chance is that this will *always* attempt to increase after a maximum of 19 months
            local delay_period = 30 * (6 + GSBase.RandRange(19));
            if ((GSDate.GetCurrentDate() - last_increase_date) < delay_period) {
                town_can_increase_primary_production = false;
            }
        }
        if (town_can_increase_primary_production == false) {
            // return early eh
            return;
        }
        else {
            Log.Info("...town is happy, and it's time to try and increase primary industrial production");
            local candidate_industries = [];
            foreach (industry, industry_spec in vulcan_town.town_industries) {
                if (industry_spec.default_vulcan_config["allow_production_change_from_gs"] == true) {
                    // filter out candidates against various criteria
                    local is_valid_candidate = true;
                    // don't increase in first 3 years after construction
                    if ((GSDate.GetCurrentDate() - GSIndustry.GetConstructionDate(industry)) < (3 * 365)) {
                        is_valid_candidate = false;
                        // continue / break here for speed?
                    }
                    // cap max production to 32, - this is 2x original base production of 16
                    // more than double isn't actually fun in FIRS (this might need tuned further by industry type)
                    if (GSIndustry.GetProductionLevel(industry) >= 32) {
                        is_valid_candidate = false;
                        // continue / break here for speed?
                    }
                    if (industry in ::persistent_storage.industry_production_increase_timeseries) {
                        local last_increase_date = ::persistent_storage.industry_production_increase_timeseries[industry][0];
                        // don't increase more than once every 10 years per industry - let's not worry about leap years here eh
                        if (GSDate.GetCurrentDate() - last_increase_date < (10 * 365)) {
                            is_valid_candidate = false;
                            // continue / break here for speed?
                        }
                    }
                    if (is_valid_candidate) {
                        candidate_industries.append(industry);
                    }
                }
            }
            // random selection from available candidates
            if (candidate_industries.len() > 0) {
                local industry = candidate_industries[GSBase.RandRange(candidate_industries.len())];
                // add linear 8 to current production level for increase of 50% on original value of 16
                // multiplying current prod by 1.33 was tried here, but later increases are too aggressive with a multiplier, linear steps are better
                local news_message = GSText(GSText.STR_NEWS_INDUSTRY_INCREASES_PRODUCTION, industry);
                GSIndustry.SetProductionLevel(industry, GSIndustry.GetProductionLevel(industry) + 8, true, news_message);
                // store the date we last increased production at this industry, so we can wait an appropriate period until the next increase
                // latest added date will be first in the list - note that using date cheat can cause unexpected results here
                if ((industry in ::persistent_storage.industry_production_increase_timeseries) == false) {
                    ::persistent_storage.industry_production_increase_timeseries[industry] <- [];
                }
                ::persistent_storage.industry_production_increase_timeseries[industry].insert(0, GSDate.GetCurrentDate());
                // we update the town attempt here as we need to be sure we actually tried to increase an industry (candidates could be 0)
                // latest added date will be first in the list - note that using date cheat can cause unexpected results here
                if ((vulcan_town.town in ::persistent_storage.town_primary_industry_production_increase_timeseries) == false) {
                    ::persistent_storage.town_primary_industry_production_increase_timeseries[vulcan_town.town] <- [];
                }
                ::persistent_storage.town_primary_industry_production_increase_timeseries[vulcan_town.town].insert(0, GSDate.GetCurrentDate());
            }
        }
    }

}

class VulcanIndustrySpec {
    // equivalent to industry spec in OpenTTD, and GSIndustryType
    // i.e. spec for industry type, not industry instance
    grf_local_id = null;
    global_id = null;
    default_vulcan_config = null;
    economy_variations = null;

    constructor(grf_local_id, global_id, default_vulcan_config, economy_variations) {
        this.grf_local_id = grf_local_id;
        this.global_id = global_id;
        this.default_vulcan_config = default_vulcan_config;
        this.economy_variations = economy_variations;
    }

    function _tostring() {
        // arbitrary string representation of the class, called by Log etc
        return GSIndustryType.GetName(this.global_id) + " grf_local_id: " + this.grf_local_id + " global_id: " + this.global_id + " vulcan config items: " + default_vulcan_config.len()
    }

    function GetMapCurator() {
        local result = null;
        if (this.economy_variations[firs.active_economy.id]["vulcan_config"] != null) {
             if ("map_curator" in this.economy_variations[firs.active_economy.id]["vulcan_config"]) {
                // note the rename to "map_curator_config" for clarity, as we will init a map_curator instance - whereas it's just "map_curator" in the python properties
                local map_curator_config = this.economy_variations[firs.active_economy.id]["vulcan_config"]["map_curator"];
                result = VulcanMapCuratorIndustryType(this, map_curator_config);
             }
        }
        return result;
    }

    function GetCount() {
        local industry_list = GSIndustryList();
        industry_list.Valuate(GSIndustry.GetIndustryType);
        industry_list.KeepValue(this.global_id);
        return industry_list.Count();
    }

    function BuildInTown(town) {
        // write our own version of prospecting, scoped to a town

        // this area isn't actually scoped to the town, it's just a circle around it in which to check tiles, we'll filter by GetClosestTown later
        local town_circular_area = AtlasCircle(GSTown.GetLocation(town), 32).GetTiles();

        local result = false;
        do {
            local rand_index = GSBase.RandRange(town_circular_area.len());
            local tile = town_circular_area[rand_index];
            town_circular_area.remove(rand_index);
            if (GSTile.GetClosestTown(tile) == town) {
                local tm = GSTestMode();
                if (GSIndustryType.BuildIndustry(this.global_id, tile) == true) {
                    local foo = GSExecMode();
                    GSIndustryType.BuildIndustry(this.global_id, tile);
                    result = true;
                    break;
                }
            }
        }
        while (town_circular_area.len() > 0);
        return result
    }
}
