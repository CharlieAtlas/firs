class VulcanIndustryControl {
    /* structure for industry control */

    // note that this has no constructor as not designed to return a class instance, just a class to hold methods
    function Init() {
        VulcanIndustryControl.SetIndustryFlagsToSpec();
    }

    function GetDefaultControlFlags() {
        // can't use class property for these as there's no class instance constructed, so use cheeky function instead
        return GSIndustry.INDCTL_NO_CLOSURE | GSIndustry.INDCTL_NO_PRODUCTION_INCREASE | GSIndustry.INDCTL_NO_PRODUCTION_DECREASE;
    }

    function SetIndustryFlagsToSpec() {
        Log.Info("SetIndustryFlagsToSpec called");
        local industry_list = GSIndustryList();
        // asyncmode for speed here as we execute commands over a potentially large number of industries
        local asyncmode = GSAsyncMode(true);
        foreach (industry, _ in industry_list) {
            // set all flags as of June 2023, unset them later per-industry for specific behaviour
            GSIndustry.SetControlFlags(industry, VulcanIndustryControl.GetDefaultControlFlags());
        }
        Log.Info("SetIndustryFlagsToSpec done");
    }

    function RollDiceForTownPrimaryIndustryProductionIncrease(vulcan_town) {
        // house keeping
        foreach (industry, industry_spec in vulcan_town.town_industries) {
            if (industry_spec.default_vulcan_config["allow_production_change_from_gs"] == true) {
                // reset any flags to defaults, we have to assume that the grf has meanwhile used the flag to change production
                GSIndustry.SetControlFlags(industry, VulcanIndustryControl.GetDefaultControlFlags());
            }
        }

        local town_can_increase_primary_production = vulcan_town.GetHappiness();
        // limit how often we try to update
        if (vulcan_town.town in ::persistent_storage.town_primary_industry_production_increase_timeseries) {
            local last_increase_date = ::persistent_storage.town_primary_industry_production_increase_timeseries[vulcan_town.town];
            // odd but cheap way to add some random jitter
            // this is expressed in days, min 180 (6 months), max 540 (18 months)
            // note this will be a new random amount *every* month, this doesn't extend the delay until the _next_ check
            local delay_period = 30 * (6 + GSBase.RandRange(19));
            if ((GSDate.GetCurrentDate() - last_increase_date) < delay_period) {
                town_can_increase_primary_production = false;
            }
        }
        if (town_can_increase_primary_production == false) {
            // return early eh
            return;
        }
        else {
            Log.Info("...town is happy, and it's time to try and increase primary industrial production");
            local candidate_industries = [];
            foreach (industry, industry_spec in vulcan_town.town_industries) {
                if (industry_spec.default_vulcan_config["allow_production_change_from_gs"] == true) {
                    // filter out candidates against various criteria
                    local is_valid_candidate = true;
                    if (industry in ::persistent_storage.industry_production_increase_timeseries) {
                        local last_increase_date = ::persistent_storage.industry_production_increase_timeseries[industry];
                        // don't increase more than once every 2 years - let's not worry about leap years here eh
                        if (GSDate.GetCurrentDate() - last_increase_date < 730) {
                            is_valid_candidate = false;
                        }
                    }
                    if (is_valid_candidate) {
                        candidate_industries.append(industry);
                    }
                }
            }
            // random selection from available candidates
            if (candidate_industries.len() > 0) {
                local candidate_industry = candidate_industries[GSBase.RandRange(candidate_industries.len())];
                local control_flags = GSIndustry.INDCTL_NO_CLOSURE | GSIndustry.INDCTL_NO_PRODUCTION_DECREASE;
                GSIndustry.SetControlFlags(candidate_industry, control_flags);
                // note that the actual industry increase is implemented in the grf and might already be maxed out, so this is date of last attempt, not last actual increase
                ::persistent_storage.industry_production_increase_timeseries[candidate_industry] <- GSDate.GetCurrentDate();
                // we update the town attempt here as we need to be sure we actually tried to increase an industry (candidates could be 0)
                ::persistent_storage.town_primary_industry_production_increase_timeseries[vulcan_town.town] <- GSDate.GetCurrentDate();
            }
        }
    }

}

class VulcanIndustrySpec {
    // equivalent to industry spec in OpenTTD, and GSIndustryType
    // i.e. spec for industry type, not industry instance
    grf_local_id = null;
    global_id = null;
    default_vulcan_config = null;
    economy_variations = null;

    constructor(grf_local_id, global_id, default_vulcan_config, economy_variations) {
        this.grf_local_id = grf_local_id;
        this.global_id = global_id;
        this.default_vulcan_config = default_vulcan_config;
        this.economy_variations = economy_variations;
    }

    function _tostring() {
        // arbitrary string representation of the class, called by Log etc
        return GSIndustryType.GetName(this.global_id) + " grf_local_id: " + this.grf_local_id + " global_id: " + this.global_id + " vulcan config items: " + default_vulcan_config.len()
    }

    function GetMapCurator() {
        local result = null;
        if (this.economy_variations[firs.active_economy.id]["vulcan_config"] != null) {
             if ("map_curator" in this.economy_variations[firs.active_economy.id]["vulcan_config"]) {
                // note the rename to "map_curator_config" for clarity, as we will init a map_curator instance - whereas it's just "map_curator" in the python properties
                local map_curator_config = this.economy_variations[firs.active_economy.id]["vulcan_config"]["map_curator"];
                result = VulcanMapCuratorIndustryType(this, map_curator_config);
             }
        }
        return result;
    }

    function GetCount()
    {
        local industry_list = GSIndustryList();
        industry_list.Valuate(GSIndustry.GetIndustryType);
        industry_list.KeepValue(this.global_id);
        return industry_list.Count();
    }

    function BuildInTown(town)
    {
        // write our own version of prospecting, scoped to a town

        // this area isn't actually scoped to the town, it's just a circle around it in which to check tiles, we'll filter by GetClosestTown later
        local town_circular_area = AtlasCircle(GSTown.GetLocation(town), 32).GetTiles();

        local result = false;
        do {
            local rand_index = GSBase.RandRange(town_circular_area.len());
            local tile = town_circular_area[rand_index];
            town_circular_area.remove(rand_index);
            if (GSTile.GetClosestTown(tile) == town) {
                local tm = GSTestMode();
                if (GSIndustryType.BuildIndustry(this.global_id, tile) == true) {
                    local foo = GSExecMode();
                    GSIndustryType.BuildIndustry(this.global_id, tile);
                    result = true;
                    break;
                }
            }
        }
        while (town_circular_area.len() > 0);
        return result
    }
}
